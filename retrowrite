#!/usr/bin/env python3

import argparse
import json
import tempfile
import subprocess
import os
import sys
import traceback
import importlib
from elftools.elf.elffile import ELFFile

def load_analysis_cache(loader, outfile):
    with open(outfile + ".analysis_cache") as fd:
        analysis = json.load(fd)
    print("[*] Loading analysis cache")
    for func, info in analysis.items():
        for key, finfo in info.items():
            loader.container.functions[int(func)].analysis[key] = dict()
            for k, v in finfo.items():
                try:
                    addr = int(k)
                except ValueError:
                    addr = k
                loader.container.functions[int(func)].analysis[key][addr] = v

def save_analysis_cache(loader, outfile):
    analysis = dict()

    for addr, func in loader.container.functions.items():
        analysis[addr] = dict()
        analysis[addr]["free_registers"] = dict()
        for k, info in func.analysis["free_registers"].items():
            analysis[addr]["free_registers"][k] = list(info)

    with open(outfile + ".analysis_cache", "w") as fd:
        json.dump(analysis, fd)


def analyze_registers(loader, args):
    StackFrameAnalysis.analyze(loader.container)
    if args.cache:
        try:
            load_analysis_cache(loader, args.outfile)
        except IOError:
            RegisterAnalysis.analyze(loader.container)
            save_analysis_cache(loader, args.outfile)
    else:
        RegisterAnalysis.analyze(loader.container)

def asan(rw, loader, args):
    analyze_registers(loader, args)

    instrumenter = Instrument(rw)
    instrumenter.do_instrument()
    instrumenter.dump_stats()


def asank(rw, loader, args):
    StackFrameAnalysis.analyze(loader.container)

    with tempfile.NamedTemporaryFile(mode='w') as cf_file:
        with tempfile.NamedTemporaryFile(mode='r') as regs_file:
            rw.dump_cf_info(cf_file)
            cf_file.flush()

            subprocess.check_call(['cftool', cf_file.name, regs_file.name])

            analysis = json.load(regs_file)

            for func, info in analysis.items():
                for key, finfo in info.items():
                    fn = loader.container.get_function_by_name(func)
                    fn.analysis[key] = dict()
                    for k, v in finfo.items():
                        try:
                            addr = int(k)
                        except ValueError:
                            addr = k
                        fn.analysis[key][addr] = v
    return rw

def fix_got_post_assembly(outfile):
    # this is only for ARM!
    # fix _GLOBAL_OFFSET_TABLE
    # _GLOBAL_OFFSET_TABLE_ is inserted by the link at the wrong place
    # (in the middle of .got instead of at the end) bc we don't link against startfiles anymore (crts)
    # so we need to do the following things:
    # 1. shift data in .got to put the _GLOBAL_OFFSET_TABLE_ in the right place
    # 2. since data was moved by 8 bytes, fix relocation offsets of all data that was moved
    # 3. we would need to move also the _GLOBAL_OFFSET_TABLE_ symbol (as it is incorrect after the
    #   move). but binaries look like they work even without moving the symbol. So this is not implemented yet.

    from elftools.elf.relocation import RelocationHandler, RelocationSection
    with open(f"{outfile}", "rb") as f:
        elffile = ELFFile(f)
        got = elffile.get_section_by_name(".got")
        symtab = elffile.get_section_by_name(".symtab")
        gottable = symtab.get_symbol_by_name("_GLOBAL_OFFSET_TABLE_")[0]['st_value']
        original_got_start = symtab.get_symbol_by_name(".got_start")[0]['st_value']
        print(f"_GLOBAL_OFFSET_TABLE_ at {hex(gottable)}")
        print(f".got_start at {hex(original_got_start)}, real got start at {hex(got['sh_addr'])}")

        virtual_got_start = got['sh_addr']
        virtual_got_end = virtual_got_start + got['sh_size']
        phy_got_start = got['sh_offset']
        phy_got_end = phy_got_start + got['sh_size']
        def phyaddr(addr):
            return phy_got_start + (addr - virtual_got_start)

        # read the value of the two fields
        f.seek(phyaddr(gottable))
        gottable_value = f.read(8)

        sz = got['sh_size'] - (original_got_start - virtual_got_start)
        f.seek(phyaddr(original_got_start))
        got_start_value = f.read(sz - 8)
        print("size", sz)

        print(f"gottable {hex(int.from_bytes(gottable_value, 'little'))}")
        f.seek(0)
        data = f.read()

        # look for relocations in .got affected by the change
        rel_to_change = []
        for section in elffile.iter_sections():
            if not isinstance(section, RelocationSection):
                continue

            # data = section.data()
            f.seek(section['sh_offset'])
            reldata = f.read(section['sh_size'])
            reldata = [reldata[i:i+8] for i in range(0, len(reldata), 8)]

            for e,x in enumerate(reldata[::3]):
                rel_addr = int.from_bytes(x, 'little')
                if original_got_start <= rel_addr <= virtual_got_end or \
                   phy_got_start <= rel_addr <= phy_got_end:
                    phy_addr = section['sh_offset'] + e*24
                    rel_to_change += [(phy_addr, rel_addr)]

    with open(f"{outfile}", "w+b") as ff:
        # switch them
        ff.seek(0)
        ff.write(data)
        ff.seek(phyaddr(original_got_start))
        ff.write(gottable_value)
        ff.seek(phyaddr(original_got_start + 8))
        ff.write(got_start_value)

        # fix up relocations 
        for addr, value in rel_to_change:
            print(f"changing reloc at {hex(addr)} from {hex(value)} to {hex(value+8)}")
            ff.seek(addr)
            ff.write((value+8).to_bytes(8, byteorder='little'))


def assemble(filename, outfile):
    size = os.stat(filename).st_size
    f = open(filename, 'r')
    f.seek(size - 1024) # we store metadata only at the end
                        # no need to read the whole file
    deps = []
    last_lines = f.readlines()
    for line in last_lines:
        if "DEPENDENCY:" in line:
            deps += [line.split(": ")[1]]

    print("Will link with the following dependencies:")
    print("".join(deps))

    lflags = []
    for d in deps:
        if "ld-linux" in d: continue
        lflags += ["-l" + d.split(".")[0].split("lib")[1]]
    lflags = " ".join(lflags)

    print("Assembling...")
    asmline = f"gcc {filename} -pie -nostartfiles {lflags} -o {outfile}"
    print(asmline)
    os.system(asmline) # TODO: check exit code
    print("Done!")

    # only for ARM:
    # if ELFFile(open(outfile, "rb")).get_machine_arch() == "AArch64":
        # fix_got_post_assembly(outfile)





if __name__ == "__main__":
    argp = argparse.ArgumentParser(description='Process some integers.')

    argp.add_argument("bin", type=str, help="Input binary to load")
    argp.add_argument("outfile", type=str, help="Symbolized ASM output")

    argp.add_argument("-a", "--assemble", action='store_true',
                      help="Assemble instrumented assembly file into instrumented binary")

    argp.add_argument("-A", "--asan", action='store_true',
                      help="Add binary address sanitizer instrumentation")
    # python3 -m rwtools.asan.asantool /bin/ls ls-basan-instrumented

    argp.add_argument("-m", "--module", type=str,
                      help="Use specified instrumentation module in rwtools directory")


    # argp.add_argument("-s", "--assembly", action="store_true",
                      # help="Generate Symbolized Assembly")
    # python3 -m librw.rw </path/to/binary> <path/to/output/asm/files>
    argp.add_argument("-k", "--kernel", action='store_true',
                      help="Instrument a kernel module")
    argp.add_argument(
        "--kcov", action='store_true', help="Instrument the kernel module with kcov")
    argp.add_argument("-c", "--cache", action='store_true',
                      help="Save/load register analysis cache (only used with --asan)")
    argp.add_argument("--ignore-no-pie", dest="ignore_no_pie", action='store_true', help="Ignore position-independent-executable check (use with caution)")
    argp.add_argument("--ignore-stripped", dest="ignore_stripped", action='store_true',
                      help="Ignore stripped executable check (use with caution)")
    argp.add_argument("-v", "--verbose", action="store_true",
            help="Verbose output")

    argp.set_defaults(ignore_no_pie=False)
    argp.set_defaults(ignore_stripped=False)

    args = argp.parse_args()

    if args.assemble:
        assemble(args.bin, args.outfile)
        exit(0)

    elffile = ELFFile(open(args.bin, "rb"))
    arch = elffile.get_machine_arch()

    rwtools_path = "rwtools."

    if arch == "AArch64":
        from arm.librw.rw import Rewriter
        from arm.librw.analysis.register import RegisterAnalysis
        from arm.librw.analysis.stackframe import StackFrameAnalysis
        from arm.rwtools.asan.instrument import Instrument
        from arm.librw.loader import Loader
        from arm.librw.analysis import register
        import arm.librw.util.logging

        rwtools_path = "arm." + rwtools_path

        if args.verbose:
            arm.librw.util.logging.DEBUG_LOG = True

    elif arch == "x64":
        if args.kernel:
            from librw.krw import Rewriter
            from librw import krw
            from librw.analysis.kregister import RegisterAnalysis
            from librw.analysis.kstackframe import StackFrameAnalysis
            from librw.kloader import Loader
            from librw.analysis import kregister
        else:
            from librw.rw import Rewriter
            from librw.analysis.register import RegisterAnalysis
            from librw.analysis.stackframe import StackFrameAnalysis
            from rwtools.asan.instrument import Instrument
            from librw.loader import Loader
            from librw.analysis import register
    else:
        print(f"Architecture {arch} not supported!")
        exit(1)

    loader = Loader(args.bin)
    if loader.is_pie() == False and args.ignore_no_pie == False:
        print("***** RetroWrite requires a position-independent executable. *****")
        print("It looks like %s is not position independent" % args.bin)
        print("If you really want to continue, because you think retrowrite has made a mistake, pass --ignore-no-pie.")
        sys.exit(1)
    if loader.is_stripped() == True and args.ignore_stripped == False:
        print("RetroWrite requires a non-stripped executable.")
        print("It looks like %s is stripped" % args.bin)
        print("If you really want to continue, because you think retrowrite has made a mistake, pass --ignore-stripped.")
        sys.exit(1)


    slist = loader.slist_from_symtab()
    if args.kernel:
        loader.load_data_sections(slist, krw.is_data_section)
    else:
        # loader.load_sections(slist, lambda x: x != ".text")
        loader.load_sections(slist, lambda x: x not in Rewriter.IGNORE_SECTIONS)
        # loader.load_data_sections(slist, lambda x: slist[x]['base'] > 0 and x not in ['.text','.plt','.init'] and ".note" not in x)

    flist = loader.flist_from_symtab()
    loader.load_functions(flist)

    reloc_list = loader.reloc_list_from_symtab()
    loader.load_relocations(reloc_list)

    global_list = loader.global_data_list_from_symtab()
    loader.load_globals_from_glist(global_list)

    loader.container.attach_loader(loader)

    rw = Rewriter(loader.container, args.outfile)
    rw.symbolize()


    if args.asan:
        if args.kernel:
            rewriter = asank(rw, loader, args)
            instrumenter = Instrument(rewriter)
            instrumenter.do_instrument()

            if args.kcov:
                kcov_instrumenter = KcovInstrument(rewriter)
                kcov_instrumenter.do_instrument()
            rewriter.dump()
        else:
            asan(rw, loader, args)
            rw.dump()
    elif args.module:
        try:
            module = importlib.import_module(rwtools_path + args.module + ".instrument")
            instrument = getattr(module, "Instrument")

            analyze_registers(loader, args)
            instrumenter = instrument(rw)
            instrumenter.do_instrument()
            rw.dump()
        except Exception as e:
            traceback.print_exc()
    else:
        rw.dump()
